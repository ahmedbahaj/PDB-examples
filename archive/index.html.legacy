<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Protein Interaction Analysis v15</title>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/modules/sankey.js"></script>
    <script src="https://code.highcharts.com/modules/dependency-wheel.js"></script>
    <script src="https://code.highcharts.com/modules/arc-diagram.js"></script>
    <script src="https://code.highcharts.com/modules/heatmap.js"></script>
    <script src="https://code.highcharts.com/modules/exporting.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', system-ui, sans-serif;
            background-color: #ffffff;
            color: #1d1d1f;
            line-height: 1.47059;
            font-weight: 400;
            letter-spacing: -0.022em;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 60px 40px;
        }

        h1 {
            font-size: 56px;
            line-height: 1.07143;
            font-weight: 600;
            letter-spacing: -0.005em;
            text-align: center;
            margin-bottom: 16px;
            color: #1d1d1f;
        }

        .subtitle {
            font-size: 24px;
            line-height: 1.16667;
            font-weight: 400;
            letter-spacing: 0.009em;
            text-align: center;
            color: #6e6e73;
            margin-bottom: 48px;
        }

        .controls-panel {
            background: #fbfbfd;
            border-radius: 18px;
            padding: 32px;
            margin-bottom: 32px;
            box-shadow: 0 2px 16px rgba(0, 0, 0, 0.04);
        }

        .control-group {
            margin-bottom: 24px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-size: 17px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 12px;
            letter-spacing: -0.022em;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #d2d2d7;
            outline: none;
            flex: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #1d1d1f;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #000000;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
            transform: scale(1.05);
        }

        input[type="range"]::-moz-range-thumb {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #1d1d1f;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.15s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #000000;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
            transform: scale(1.05);
        }

        .slider-value {
            font-size: 17px;
            font-weight: 600;
            color: #1d1d1f;
            min-width: 80px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .stat-card {
            background: #ffffff;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid #d2d2d7;
        }

        .stat-value {
            font-size: 32px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 14px;
            color: #6e6e73;
            font-weight: 500;
        }

        #chartContainer {
            background: #ffffff;
            border-radius: 18px;
            padding: 32px;
            box-shadow: 0 2px 16px rgba(0, 0, 0, 0.04);
            min-height: 850px;
        }

        .legend {
            background: #fbfbfd;
            border-radius: 18px;
            padding: 24px 32px;
            margin-top: 32px;
            box-shadow: 0 2px 16px rgba(0, 0, 0, 0.04);
        }

        .legend-title {
            font-size: 19px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 16px;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 32px;
            height: 4px;
            border-radius: 2px;
        }

        .legend-label {
            font-size: 14px;
            color: #1d1d1f;
            font-weight: 500;
        }

        .loading {
            text-align: center;
            padding: 100px 20px;
            color: #6e6e73;
            font-size: 19px;
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid #d2d2d7;
            border-top-color: #1d1d1f;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        button {
            background: #1d1d1f;
            color: white;
            border: none;
            border-radius: 980px;
            padding: 12px 24px;
            font-size: 17px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: inherit;
            letter-spacing: -0.022em;
        }

        button:hover {
            background: #000000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }

        button:active {
            transform: scale(0.98);
        }

        button.secondary {
            background: #f5f5f7;
            color: #1d1d1f;
        }

        button.secondary:hover {
            background: #e8e8ed;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .chart-selector {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-bottom: 32px;
        }

        .chart-btn {
            background: #f5f5f7;
            color: #1d1d1f;
            border: 2px solid transparent;
            border-radius: 980px;
            padding: 12px 32px;
            font-size: 17px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            letter-spacing: -0.022em;
        }

        .chart-btn:hover {
            background: #e8e8ed;
        }

        .chart-btn.active {
            background: #1d1d1f;
            color: white;
            border-color: #1d1d1f;
        }

        .chart-btn.active:hover {
            background: #000000;
        }

        .slider-container-wrapper {
            display: block;
        }

        .slider-container-wrapper.hidden {
            display: none;
        }

        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: #fbfbfd;
            border-right: 1px solid #d2d2d7;
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
        }

        .sidebar-title {
            font-size: 17px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #d2d2d7;
        }

        .upload-btn {
            width: 100%;
            margin-bottom: 20px;
            padding: 12px;
            background: #1d1d1f;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .upload-btn:hover {
            background: #000000;
            transform: translateY(-1px);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #ffffff;
            padding: 40px;
            border-radius: 24px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .modal-title {
            font-size: 24px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 24px;
            text-align: center;
        }

        .dropzone {
            border: 2px dashed #d2d2d7;
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fbfbfd;
        }

        .dropzone:hover, .dropzone.dragover {
            border-color: #1d1d1f;
            background: #f5f5f7;
        }

        .dropzone-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .dropzone-text {
            font-size: 17px;
            color: #1d1d1f;
            margin-bottom: 8px;
        }

        .dropzone-subtext {
            font-size: 14px;
            color: #6e6e73;
        }

        .progress-container {
            margin-top: 24px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e8e8ed;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .progress-fill {
            height: 100%;
            background: #1d1d1f;
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            font-size: 14px;
            color: #6e6e73;
        }

        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #f5f5f7;
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: #e8e8ed;
        }

        .system-item {
            padding: 12px 16px;
            margin-bottom: 8px;
            border-radius: 12px;
            background: #ffffff;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .system-item:hover {
            background: #f5f5f7;
        }

        .system-item.active {
            background: #1d1d1f;
            color: #ffffff;
            border-color: #1d1d1f;
        }

        .system-name {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .system-frames {
            font-size: 12px;
            color: #6e6e73;
        }

        .system-item.active .system-frames {
            color: #d2d2d7;
        }

        .main-content {
            margin-left: 280px;
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
                border-right: none;
                border-bottom: 1px solid #d2d2d7;
            }
            
            .main-content {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-title">Analysis Systems</div>
        <button class="upload-btn" onclick="openUploadModal()">+ Upload PDB File</button>
        <div id="systemsList">
            <!-- System items will be dynamically generated -->
        </div>
    </div>

    <!-- Upload Modal -->
    <div id="uploadModal" class="modal">
        <div class="modal-content" style="position: relative;">
            <button class="close-btn" onclick="closeUploadModal()">√ó</button>
            <div class="modal-title">Upload PDB File</div>
            
            <div id="dropzone" class="dropzone">
                <div class="dropzone-icon">üìÅ</div>
                <div class="dropzone-text">Drag & drop your PDB file here</div>
                <div class="dropzone-subtext">or click to browse</div>
            </div>
            
            <input type="file" id="fileInput" accept=".pdb" style="display: none;">
            
            <div id="progressContainer" class="progress-container">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
                <div id="progressText" class="progress-text">Uploading...</div>
            </div>
        </div>
    </div>
    
    <div class="main-content">
    <div class="container">
        <h1>Protein Interaction Analysis</h1>
        <p class="subtitle" id="systemSubtitle">1ULL - Chain A ‚Üî Chain B Residue Interactions Across Frames</p>

        <div class="chart-selector">
            <button class="chart-btn active" id="arcBtn" onclick="switchChart('arc')">Arc Diagram</button>
            <button class="chart-btn" id="chordBtn" onclick="switchChart('chord')">Chord Diagram</button>
            <button class="chart-btn" id="heatmapBtn" onclick="switchChart('heatmap')">Heatmap</button>
            <button class="chart-btn" id="filteredHeatmapBtn" onclick="switchChart('filteredHeatmap')">Filtered Heatmap</button>
            <button class="chart-btn" id="areaBtn" onclick="switchChart('area')">Area Chart</button>
            <button class="chart-btn" id="lineBtn" onclick="switchChart('line')">Interaction Trends</button>
        </div>

        <div class="controls-panel">
            <div class="control-group slider-container-wrapper" id="sliderControl">
                <label for="consistencySlider">Consistency Threshold</label>
                <div class="slider-container">
                    <input type="range" id="consistencySlider" min="0.5" max="1" step="0.01" value="0.6">
                    <span class="slider-value" id="sliderValue">60%</span>
                </div>
                <p style="font-size: 14px; color: #6e6e73; margin-top: 8px;">
                    Show interactions present in at least <span id="percentText">60%</span> of frames
                </p>
            </div>

            <div class="control-group slider-container-wrapper hidden" id="logScaleControl">
                <label for="logScaleToggle">Chart Scale</label>
                <div style="display: flex; gap: 12px; align-items: center;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin: 0;">
                        <input type="checkbox" id="logScaleToggle" style="width: 20px; height: 20px; cursor: pointer; accent-color: #1d1d1f;">
                        <span style="font-size: 15px; font-weight: 500; color: #1d1d1f;">Use Logarithmic Scale</span>
                    </label>
                </div>
                <p style="font-size: 14px; color: #6e6e73; margin-top: 8px;">
                    Enable to better visualize differences when values vary greatly
                </p>
            </div>

            <div class="control-group slider-container-wrapper hidden" id="colorSchemeControl">
                <label for="colorSchemeSelect">Color Scheme</label>
                <select id="colorSchemeSelect" style="width: 100%; padding: 12px; font-size: 15px; border-radius: 8px; border: 1px solid #d2d2d7; background: #ffffff; color: #1d1d1f; font-family: inherit; cursor: pointer;">
                    <option value="classic">Classic</option>
                    <option value="vibrant">Vibrant</option>
                    <option value="pastel">Pastel</option>
                    <option value="dark">Dark Mode</option>
                    <option value="scientific">Scientific</option>
                </select>
                <p style="font-size: 14px; color: #6e6e73; margin-top: 8px;">
                    Choose a color palette for interaction types
                </p>
            </div>

            <div class="control-group slider-container-wrapper hidden" id="interactionFilterControl">
                <label>Filter Interaction Types</label>
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button type="button" onclick="selectAllInteractionTypes()" class="secondary" style="padding: 8px 16px; font-size: 14px;">Select All</button>
                    <button type="button" onclick="deselectAllInteractionTypes()" class="secondary" style="padding: 8px 16px; font-size: 14px;">Deselect All</button>
                </div>
                <div id="interactionTypeCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; max-height: 200px; overflow-y: auto; padding: 12px; background: #f5f5f7; border-radius: 12px;">
                    <!-- Checkboxes will be dynamically generated -->
                </div>
            </div>

            <div class="control-group">
                <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalInteractions">-</div>
                    <div class="stat-label">Total Interactions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="visibleInteractions">-</div>
                    <div class="stat-label">Visible Interactions</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgConsistency">-</div>
                    <div class="stat-label">Avg Consistency</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalFramesStat">7</div>
                    <div class="stat-label">Total Frames</div>
                </div>
                </div>
            </div>
        </div>

        <div id="chartContainer">
            <div class="loading">
                <div class="loading-spinner"></div>
                <div>Loading interaction data...</div>
            </div>
        </div>

        <div class="legend" id="arcLegend">
            <div class="legend-title">Interaction Type Colors <span style="font-size: 13px; color: #6e6e73; font-weight: 400;">(use Color Scheme selector to change)</span></div>
            <div class="legend-grid">
                <div class="legend-item">
                    <div class="legend-color" style="background: rgb(29, 29, 31);"></div>
                    <div class="legend-label">H-bond</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgb(255, 59, 48);"></div>
                    <div class="legend-label">Salt-bridge</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgb(175, 82, 222);"></div>
                    <div class="legend-label">œÄ-œÄ Stacking</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgb(255, 149, 0);"></div>
                    <div class="legend-label">Cation/Anion-œÄ</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgb(255, 204, 0);"></div>
                    <div class="legend-label">C-H‚Ä¶O/N</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgb(88, 86, 214);"></div>
                    <div class="legend-label">Halogen Bond</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgb(52, 199, 89);"></div>
                    <div class="legend-label">Van der Waals</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgb(142, 142, 147);"></div>
                    <div class="legend-label">Proximal</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgb(255, 45, 85);"></div>
                    <div class="legend-label">Clash</div>
                </div>
            </div>
        </div>
    </div>
    </div>

    <script>
        let allInteractionsData = [];
        let areaData = [];
        let interactionTrendsData = [];
        let chart = null;
        let currentSystem = '1ULL';
        let totalFrames = 7;
        let currentChartType = 'arc';
        let currentThreshold = 0.6;
        let useLogScale = false;
        let selectedInteractionTypes = new Set();
        let currentColorScheme = 'classic';
        
        // Define available systems
        const SYSTEMS = [
            { id: '1ULL', name: '1ULL', path: '1ULL', frames: 7 },
            { id: 'md_mohit_protein', name: 'MD Mohit Protein', path: 'md_mohit_protein', frames: 11 },
            { id: 'md_mohit_system', name: 'MD Mohit System', path: 'md_mohit_system', frames: 3 }
        ];
        
        // Define color schemes
        const COLOR_SCHEMES = {
            classic: {
                'h-bond': [29, 29, 31],
                'salt-bridge': [255, 59, 48],
                'pi-pi': [175, 82, 222],
                'cation-anion-pi': [255, 149, 0],
                'ch-on': [255, 204, 0],
                'halogen': [88, 86, 214],
                'vdw': [52, 199, 89],
                'proximal': [142, 142, 147],
                'clash': [255, 45, 85]
            },
            vibrant: {
                'h-bond': [255, 0, 127],
                'salt-bridge': [255, 87, 34],
                'pi-pi': [156, 39, 176],
                'cation-anion-pi': [255, 193, 7],
                'ch-on': [76, 175, 80],
                'halogen': [3, 169, 244],
                'vdw': [0, 188, 212],
                'proximal': [158, 158, 158],
                'clash': [244, 67, 54]
            },
            pastel: {
                'h-bond': [179, 157, 219],
                'salt-bridge': [255, 183, 178],
                'pi-pi': [206, 147, 216],
                'cation-anion-pi': [255, 224, 178],
                'ch-on': [255, 245, 157],
                'halogen': [179, 229, 252],
                'vdw': [200, 230, 201],
                'proximal': [224, 224, 224],
                'clash': [255, 138, 128]
            },
            dark: {
                'h-bond': [26, 35, 126],
                'salt-bridge': [183, 28, 28],
                'pi-pi': [74, 20, 140],
                'cation-anion-pi': [230, 81, 0],
                'ch-on': [249, 168, 37],
                'halogen': [13, 71, 161],
                'vdw': [27, 94, 32],
                'proximal': [66, 66, 66],
                'clash': [136, 14, 79]
            },
            scientific: {
                'h-bond': [55, 126, 184],
                'salt-bridge': [228, 26, 28],
                'pi-pi': [152, 78, 163],
                'cation-anion-pi': [255, 127, 0],
                'ch-on': [77, 175, 74],
                'halogen': [166, 86, 40],
                'vdw': [247, 129, 191],
                'proximal': [153, 153, 153],
                'clash': [255, 255, 51]
            }
        };
        
        // Define all interaction types
        const INTERACTION_TYPES = [
            { id: 'h-bond', label: 'H-bond', keywords: ['h-bond'] },
            { id: 'salt-bridge', label: 'Salt-bridge', keywords: ['salt-bridge', 'salt bridge'] },
            { id: 'pi-pi', label: 'œÄ-œÄ interactions', keywords: ['pi-pi', 'œÄ-œÄ'] },
            { id: 'cation-pi', label: 'Cation-œÄ', keywords: ['cation-œÄ', 'cation-pi'] },
            { id: 'anion-pi', label: 'Anion-œÄ', keywords: ['anion-œÄ', 'anion-pi'] },
            { id: 'ch-on', label: 'CH-O/N bonds', keywords: ['ch-o', 'c-h'] },
            { id: 'ch-pi', label: 'CH-œÄ', keywords: ['ch-œÄ', 'ch-pi'] },
            { id: 'halogen', label: 'Halogen bonds', keywords: ['halogen'] },
            { id: 'polar-vdw', label: 'Polar vdW', keywords: ['polar vdw', 'polar_vdw'] },
            { id: 'apolar-vdw', label: 'Apolar vdW', keywords: ['apolar vdw', 'apolar_vdw'] },
            { id: 'proximal', label: 'Proximal', keywords: ['proximal'] },
            { id: 'clash', label: 'Clash', keywords: ['clash'] },
            { id: 'water', label: 'Water mediated', keywords: ['water'] },
            { id: 'metal', label: 'Metal mediated', keywords: ['metal'] },
            { id: 'ss-bond', label: 'S-S bonds', keywords: ['s-s', 'ss'] }
        ];

        // Parse CSV content
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',');
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length >= 8) {
                    const row = {
                        resName1: values[1],
                        resNum1: values[2],
                        chain1: values[3],
                        resName2: values[4],
                        resNum2: values[5],
                        chain2: values[6],
                        interactionType: values[7]
                    };
                    data.push(row);
                }
            }
            return data;
        }

        // Initialize sidebar
        function initializeSidebar() {
            const systemsList = document.getElementById('systemsList');
            systemsList.innerHTML = '';
            
            SYSTEMS.forEach(system => {
                const item = document.createElement('div');
                item.className = `system-item ${system.id === currentSystem ? 'active' : ''}`;
                item.onclick = () => switchSystem(system.id);
                
                item.innerHTML = `
                    <div class="system-name">${system.name}</div>
                    <div class="system-frames">${system.frames} frames</div>
                `;
                
                systemsList.appendChild(item);
            });
        }
        
        // Switch to different system
        async function switchSystem(systemId) {
            if (systemId === currentSystem) return;
            
            currentSystem = systemId;
            const system = SYSTEMS.find(s => s.id === systemId);
            totalFrames = system.frames;
            
            // Update sidebar active state
            document.querySelectorAll('.system-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.system-item').classList.add('active');
            
            // Update subtitle
            document.getElementById('systemSubtitle').textContent = `${system.name} - Chain A ‚Üî Chain B Residue Interactions Across Frames`;
            
            // Show loading state
            document.getElementById('chartContainer').innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div>Loading ${system.name} data...</div>
                </div>
            `;
            
            // Clear existing data
            allInteractionsData = [];
            areaData = [];
            interactionTrendsData = [];
            
            // Reload all data
            await loadAllInteractions();
            await loadAreaData();
            await loadInteractionTrends();
            
            // Update stats
            updateStats();
            
            // Refresh current chart
            if (currentChartType === 'arc') {
                updateChart(currentThreshold);
            } else if (currentChartType === 'chord') {
                updateChordDiagram(currentThreshold);
            } else if (currentChartType === 'heatmap') {
                updateHeatmap();
            } else if (currentChartType === 'filteredHeatmap') {
                updateFilteredHeatmap(currentThreshold);
            } else if (currentChartType === 'area') {
                updateAreaChart();
            } else if (currentChartType === 'line') {
                updateLineChart(useLogScale);
            }
        }
        
        // Load all interaction files
        async function loadAllInteractions() {
            const interactionMap = new Map();
            const system = SYSTEMS.find(s => s.id === currentSystem);
            
            for (let frame = 1; frame <= totalFrames; frame++) {
                try {
                    const response = await fetch(`../${system.path}/frame_${frame}/frame_${frame}.pd_h.pdb_A_B_final_file.csv`);
                    const text = await response.text();
                    const interactions = parseCSV(text);
                    
                    interactions.forEach(interaction => {
                        // Create unique key for each residue-residue interaction
                        const key = `${interaction.resName1}${interaction.resNum1}_${interaction.resName2}${interaction.resNum2}`;
                        
                        if (!interactionMap.has(key)) {
                            interactionMap.set(key, {
                                resName1: interaction.resName1,
                                resNum1: parseInt(interaction.resNum1),
                                chain1: interaction.chain1,
                                resName2: interaction.resName2,
                                resNum2: parseInt(interaction.resNum2),
                                chain2: interaction.chain2,
                                frames: new Set(),
                                types: new Set()
                            });
                        }
                        
                        const entry = interactionMap.get(key);
                        entry.frames.add(frame);
                        if (interaction.interactionType) {
                            entry.types.add(interaction.interactionType.trim());
                        }
                    });
                } catch (error) {
                    console.error(`Error loading frame ${frame}:`, error);
                }
            }
            
            // Convert to array with consistency scores
            allInteractionsData = Array.from(interactionMap.values()).map(entry => ({
                ...entry,
                frameCount: entry.frames.size,
                consistency: entry.frames.size / totalFrames,
                id1: `A-${entry.resName1}${entry.resNum1}`,
                id2: `B-${entry.resName2}${entry.resNum2}`,
                typesArray: Array.from(entry.types)
            }));
            
            // Sort by consistency
            allInteractionsData.sort((a, b) => b.consistency - a.consistency);
            
            updateStats();
            if (currentChartType === 'arc') {
                updateChart(0.6);
            } else if (currentChartType === 'chord') {
                updateChordDiagram(0.6);
            }
        }

        // Load area data from RSA stats files (specific rows)
        async function loadAreaData() {
            const frames = [];
            const system = SYSTEMS.find(s => s.id === currentSystem);
            
            for (let frame = 1; frame <= totalFrames; frame++) {
                try {
                    const response = await fetch(`../${system.path}/frame_${frame}/frame_${frame}.pd_h.pdb_A_B_complex.pdb_Rsa_stats.csv`);
                    const text = await response.text();
                    const lines = text.trim().split('\n');
                    
                    let totalBSA = 0;
                    let polarBSA = 0;
                    let nonPolarBSA = 0;
                    
                    // Parse CSV - row 0: Total BSA, row 2: POLAR BSA, row 4: NON POLAR BSA
                    lines.forEach((line, index) => {
                        const parts = line.split(',');
                        if (parts.length >= 3) {
                            const rowIndex = parseInt(parts[0]);
                            const value = parts[2];
                            
                            // Row 0: Total BSA
                            if (rowIndex === 0) {
                                const match = value.match(/([0-9.]+)\s*\/\s*/);
                                if (match) {
                                    totalBSA = parseFloat(match[1]);
                                }
                            }
                            
                            // Row 2: POLAR BSA
                            if (rowIndex === 2) {
                                const match = value.match(/([0-9.]+)\s*\/\s*/);
                                if (match) {
                                    polarBSA = parseFloat(match[1]);
                                }
                            }
                            
                            // Row 4: NON POLAR BSA
                            if (rowIndex === 4) {
                                const match = value.match(/([0-9.]+)\s*\/\s*/);
                                if (match) {
                                    nonPolarBSA = parseFloat(match[1]);
                                }
                            }
                        }
                    });
                    
                    frames.push({
                        frame: frame,
                        totalBSA: totalBSA,
                        polarBSA: polarBSA,
                        nonPolarBSA: nonPolarBSA
                    });
                    
                } catch (error) {
                    console.error(`Error loading area data for frame ${frame}:`, error);
                }
            }
            
            areaData = frames;
        }

        // Load interaction trends data from summary tables
        async function loadInteractionTrends() {
            const interactionTypes = {
                'H-bonds': [],
                'Salt-bridges': [],
                'œÄ-œÄ interactions': [],
                'Cation-œÄ interactions': [],
                'Anion-œÄ interactions': [],
                'CH-O/N bonds': [],
                'CH-œÄ interactions': [],
                'Halogen bonds': [],
                'Apolar vdW contacts': [],
                'Polar vdW contacts': [],
                'Proximal contacts': [],
                'Clashes': []
            };
            
            const system = SYSTEMS.find(s => s.id === currentSystem);
            
            for (let frame = 1; frame <= totalFrames; frame++) {
                try {
                    const response = await fetch(`../${system.path}/frame_${frame}/frame_${frame}.pd_h.pdb_A_B_summary_table.csv`);
                    const text = await response.text();
                    const lines = text.trim().split('\n');
                    
                    lines.forEach(line => {
                        const parts = line.split(',');
                        if (parts.length >= 3) {
                            const property = parts[1];
                            const value = parseInt(parts[2]);
                            
                            if (property && property.includes('H-bonds')) {
                                interactionTypes['H-bonds'].push(value);
                            } else if (property && property.includes('Salt-bridges')) {
                                interactionTypes['Salt-bridges'].push(value);
                            } else if (property && property.includes('œÄ-œÄ interactions') && !property.includes('Cation') && !property.includes('Anion')) {
                                interactionTypes['œÄ-œÄ interactions'].push(value);
                            } else if (property && property.includes('Cation-œÄ')) {
                                interactionTypes['Cation-œÄ interactions'].push(value);
                            } else if (property && property.includes('Anion-œÄ')) {
                                interactionTypes['Anion-œÄ interactions'].push(value);
                            } else if (property && property.includes('CH-O/N bonds')) {
                                interactionTypes['CH-O/N bonds'].push(value);
                            } else if (property && property.includes('CH-œÄ interactions')) {
                                interactionTypes['CH-œÄ interactions'].push(value);
                            } else if (property && property.includes('Halogen bonds')) {
                                interactionTypes['Halogen bonds'].push(value);
                            } else if (property && property.includes('Apolar vdW')) {
                                interactionTypes['Apolar vdW contacts'].push(value);
                            } else if (property && property.includes('Polar vdW')) {
                                interactionTypes['Polar vdW contacts'].push(value);
                            } else if (property && property.includes('Proximal contacts')) {
                                interactionTypes['Proximal contacts'].push(value);
                            } else if (property && property.includes('Clashes')) {
                                interactionTypes['Clashes'].push(value);
                            }
                        }
                    });
                } catch (error) {
                    console.error(`Error loading interaction trends for frame ${frame}:`, error);
                }
            }
            
            interactionTrendsData = interactionTypes;
        }

        // Initialize interaction type filter
        function initializeInteractionFilter() {
            const container = document.getElementById('interactionTypeCheckboxes');
            container.innerHTML = '';
            
            // Select all by default
            INTERACTION_TYPES.forEach(type => {
                selectedInteractionTypes.add(type.id);
                
                const checkboxDiv = document.createElement('div');
                checkboxDiv.style.cssText = 'display: flex; align-items: center; gap: 6px;';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `filter-${type.id}`;
                checkbox.checked = true;
                checkbox.style.cssText = 'width: 18px; height: 18px; cursor: pointer; accent-color: #1d1d1f;';
                checkbox.addEventListener('change', () => toggleInteractionType(type.id));
                
                const label = document.createElement('label');
                label.htmlFor = `filter-${type.id}`;
                label.textContent = type.label;
                label.style.cssText = 'font-size: 13px; color: #1d1d1f; cursor: pointer; user-select: none;';
                
                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            });
        }
        
        // Toggle interaction type
        function toggleInteractionType(typeId) {
            const checkbox = document.getElementById(`filter-${typeId}`);
            if (checkbox.checked) {
                selectedInteractionTypes.add(typeId);
            } else {
                selectedInteractionTypes.delete(typeId);
            }
            
            // Refresh current chart
            if (currentChartType === 'arc') {
                updateChart(currentThreshold);
            } else if (currentChartType === 'chord') {
                updateChordDiagram(currentThreshold);
            } else if (currentChartType === 'heatmap') {
                updateHeatmap();
            } else if (currentChartType === 'filteredHeatmap') {
                updateFilteredHeatmap(currentThreshold);
            }
        }
        
        // Select all interaction types
        function selectAllInteractionTypes() {
            INTERACTION_TYPES.forEach(type => {
                selectedInteractionTypes.add(type.id);
                const checkbox = document.getElementById(`filter-${type.id}`);
                if (checkbox) checkbox.checked = true;
            });
            
            if (currentChartType === 'arc') {
                updateChart(currentThreshold);
            } else if (currentChartType === 'chord') {
                updateChordDiagram(currentThreshold);
            } else if (currentChartType === 'heatmap') {
                updateHeatmap();
            } else if (currentChartType === 'filteredHeatmap') {
                updateFilteredHeatmap(currentThreshold);
            }
        }
        
        // Deselect all interaction types
        function deselectAllInteractionTypes() {
            selectedInteractionTypes.clear();
            INTERACTION_TYPES.forEach(type => {
                const checkbox = document.getElementById(`filter-${type.id}`);
                if (checkbox) checkbox.checked = false;
            });
            
            if (currentChartType === 'arc') {
                updateChart(currentThreshold);
            } else if (currentChartType === 'chord') {
                updateChordDiagram(currentThreshold);
            } else if (currentChartType === 'heatmap') {
                updateHeatmap();
            } else if (currentChartType === 'filteredHeatmap') {
                updateFilteredHeatmap(currentThreshold);
            }
        }
        
        // Check if interaction matches selected types
        function matchesSelectedTypes(interactionTypes) {
            if (selectedInteractionTypes.size === 0) return false;
            
            const typesLower = interactionTypes.toLowerCase();
            
            for (const typeId of selectedInteractionTypes) {
                const type = INTERACTION_TYPES.find(t => t.id === typeId);
                if (type) {
                    for (const keyword of type.keywords) {
                        if (typesLower.includes(keyword.toLowerCase())) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Update statistics
        function updateStats() {
            document.getElementById('totalInteractions').textContent = allInteractionsData.length;
            document.getElementById('totalFramesStat').textContent = totalFrames;
            
            const avgConsistency = allInteractionsData.reduce((sum, d) => sum + d.consistency, 0) / allInteractionsData.length;
            document.getElementById('avgConsistency').textContent = Math.round(avgConsistency * 100) + '%';
        }

        // Get color based on interaction type
        function getInteractionColor(types, consistency) {
            const typeString = types.toLowerCase();
            const scheme = COLOR_SCHEMES[currentColorScheme];
            let baseColor;
            
            if (typeString.includes('h-bond')) {
                baseColor = scheme['h-bond'];
            } else if (typeString.includes('salt-bridge') || typeString.includes('salt bridge')) {
                baseColor = scheme['salt-bridge'];
            } else if (typeString.includes('pi-pi') || typeString.includes('œÄ-œÄ')) {
                baseColor = scheme['pi-pi'];
            } else if (typeString.includes('cation') || typeString.includes('anion')) {
                baseColor = scheme['cation-anion-pi'];
            } else if (typeString.includes('ch-o') || typeString.includes('c-h')) {
                baseColor = scheme['ch-on'];
            } else if (typeString.includes('halogen')) {
                baseColor = scheme['halogen'];
            } else if (typeString.includes('vdw') || typeString.includes('apolar') || typeString.includes('polar')) {
                baseColor = scheme['vdw'];
            } else if (typeString.includes('proximal')) {
                baseColor = scheme['proximal'];
            } else if (typeString.includes('clash')) {
                baseColor = scheme['clash'];
            } else {
                baseColor = scheme['h-bond']; // Default to h-bond color
            }
            
            const opacity = 0.3 + (consistency * 0.6);
            return `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${opacity})`;
        }

        // Update chart based on threshold
        function updateChart(threshold) {
            // Filter by threshold and interaction types
            const filteredData = allInteractionsData.filter(d => {
                if (d.consistency < threshold) return false;
                if (selectedInteractionTypes.size === 0) return false;
                
                // Check if any of the interaction types match
                const typesString = d.typesArray.join('; ');
                return matchesSelectedTypes(typesString);
            });
            
            document.getElementById('visibleInteractions').textContent = filteredData.length;
            
            // Prepare data for arc diagram
            const nodes = new Set();
            const links = [];
            
            filteredData.forEach(interaction => {
                nodes.add(interaction.id1);
                nodes.add(interaction.id2);
                
                links.push({
                    from: interaction.id1,
                    to: interaction.id2,
                    weight: interaction.frameCount,
                    consistency: interaction.consistency,
                    types: interaction.typesArray.join('; ')
                });
            });
            
            // Create nodes array with dataLabels
            const nodesArray = Array.from(nodes).map(id => ({
                id: id,
                name: id,
                color: id.startsWith('A-') ? '#3B6EF5' : '#FF8A4C',
                dataLabels: {
                    enabled: true,
                    format: '{point.name}',
                    style: {
                        fontSize: '11px',
                        fontWeight: '600',
                        textOutline: 'none',
                        color: '#1d1d1f'
                    },
                    rotation: -90,
                    align: 'left',
                    verticalAlign: 'middle',
                    y: 10,
                    x: 0
                }
            }));
            
            // Sort nodes for better layout
            nodesArray.sort((a, b) => {
                if (a.id.startsWith('A-') && !b.id.startsWith('A-')) return -1;
                if (!a.id.startsWith('A-') && b.id.startsWith('A-')) return 1;
                
                const numA = parseInt(a.id.match(/\d+/)[0]);
                const numB = parseInt(b.id.match(/\d+/)[0]);
                return numA - numB;
            });
            
            if (chart) {
                chart.destroy();
            }
            
            chart = Highcharts.chart('chartContainer', {
                chart: {
                    type: 'arcdiagram',
                    backgroundColor: 'transparent',
                    height: 850,
                    marginBottom: 100,
                    marginTop: 80
                },
                title: {
                    text: `Residue Interaction Network (${filteredData.length} interactions)`,
                    style: {
                        fontSize: '24px',
                        fontWeight: '600',
                        color: '#1d1d1f'
                    }
                },
                subtitle: {
                    text: `Chain A (blue) ‚Üî Chain B (orange) | Threshold: ${Math.round(threshold * 100)}%`,
                    style: {
                        fontSize: '17px',
                        color: '#6e6e73'
                    }
                },
                credits: {
                    enabled: false
                },
                plotOptions: {
                    arcdiagram: {
                        linkWeight: 2,
                        centeredLinks: true,
                        reversed: false,
                        marker: {
                            fillOpacity: 1,
                            lineWidth: 3,
                            lineColor: '#ffffff',
                            radius: 18,
                            states: {
                                hover: {
                                    radius: 22,
                                    lineWidth: 3
                                }
                            }
                        },
                        states: {
                            hover: {
                                linkOpacity: 1,
                                opacity: 1
                            }
                        }
                    }
                },
                series: [{
                    keys: ['from', 'to', 'weight'],
                    type: 'arcdiagram',
                    name: 'Interactions',
                    nodes: nodesArray,
                    data: links.map(link => ({
                        from: link.from,
                        to: link.to,
                        weight: link.weight,
                        color: getInteractionColor(link.types, link.consistency),
                        consistency: link.consistency,
                        types: link.types,
                        dataLabels: {
                            enabled: false
                        }
                    })),
                    linkOpacity: 0.75,
                    offset: '100%',
                    dataLabels: {
                        enabled: false,
                        linkFormat: ''
                    }
                }],
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.98)',
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: '#d2d2d7',
                    shadow: {
                        color: 'rgba(0,0,0,0.1)',
                        offsetX: 0,
                        offsetY: 2,
                        opacity: 0.15,
                        width: 8
                    },
                    style: {
                        fontSize: '14px',
                        fontWeight: '400'
                    },
                    useHTML: true,
                    formatter: function() {
                        if (this.point.from) {
                            // This is a link/arc
                            return `
                                <div style="padding: 10px;">
                                    <div style="font-size: 15px; color: #1d1d1f; font-weight: 600; margin-bottom: 8px;">
                                        ${this.point.from} ‚Üî ${this.point.to}
                                    </div>
                                    <div style="margin-bottom: 4px;">
                                        <span style="color: #1d1d1f; font-weight: 600;">Consistency: ${Math.round(this.point.consistency * 100)}%</span>
                                    </div>
                                    <div style="margin-bottom: 4px;">
                                        <span style="color: #6e6e73;">Frames: ${this.point.weight} / ${totalFrames}</span>
                                    </div>
                                    <div style="color: #6e6e73; font-size: 12px; margin-top: 6px; padding-top: 6px; border-top: 1px solid #e8e8ed;">
                                        ${this.point.types}
                                    </div>
                                </div>
                            `;
                        } else if (this.point.name) {
                            // This is a node
                            return `
                                <div style="padding: 8px 12px;">
                                    <strong style="color: #1d1d1f; font-size: 14px;">${this.point.name}</strong>
                                </div>
                            `;
                        }
                        return false;
                    }
                }
            });
        }

        // Update chord diagram based on threshold
        function updateChordDiagram(threshold) {
            const filteredData = allInteractionsData.filter(d => {
                if (d.consistency < threshold) return false;
                if (selectedInteractionTypes.size === 0) return false;
                
                const typesString = d.typesArray.join('; ');
                return matchesSelectedTypes(typesString);
            });
            
            document.getElementById('visibleInteractions').textContent = filteredData.length;
            
            const nodes = new Map();
            const links = filteredData.map(interaction => {
                if (!nodes.has(interaction.id1)) {
                    nodes.set(interaction.id1, {
                        id: interaction.id1,
                        name: interaction.id1,
                        color: '#3B6EF5',
                        dataLabels: {
                            color: '#1d1d1f',
                            style: {
                                fontSize: '11px',
                                fontWeight: '600',
                                textOutline: 'none'
                            }
                        }
                    });
                }
                
                if (!nodes.has(interaction.id2)) {
                    nodes.set(interaction.id2, {
                        id: interaction.id2,
                        name: interaction.id2,
                        color: '#FF8A4C',
                        dataLabels: {
                            color: '#1d1d1f',
                            style: {
                                fontSize: '11px',
                                fontWeight: '600',
                                textOutline: 'none'
                            }
                        }
                    });
                }
                
                return {
                    from: interaction.id1,
                    to: interaction.id2,
                    weight: interaction.frameCount,
                    consistency: interaction.consistency,
                    types: interaction.typesArray.join('; '),
                    color: getInteractionColor(interaction.typesArray.join('; '), interaction.consistency)
                };
            });
            
            const nodesArray = Array.from(nodes.values()).sort((a, b) => {
                if (a.id.startsWith('A-') && !b.id.startsWith('A-')) return -1;
                if (!a.id.startsWith('A-') && b.id.startsWith('A-')) return 1;
                const numA = parseInt(a.id.match(/\d+/)[0]);
                const numB = parseInt(b.id.match(/\d+/)[0]);
                return numA - numB;
            });
            
            if (chart) {
                chart.destroy();
            }
            
            chart = Highcharts.chart('chartContainer', {
                chart: {
                    type: 'dependencywheel',
                    backgroundColor: 'transparent',
                    height: 850,
                    marginTop: 80
                },
                title: {
                    text: `Residue Interaction Chord (${filteredData.length} interactions)`,
                    style: {
                        fontSize: '24px',
                        fontWeight: '600',
                        color: '#1d1d1f'
                    }
                },
                subtitle: {
                    text: `Chain A ‚Üî Chain B | Threshold: ${Math.round(threshold * 100)}%`,
                    style: {
                        fontSize: '17px',
                        color: '#6e6e73'
                    }
                },
                credits: {
                    enabled: false
                },
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.98)',
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: '#d2d2d7',
                    shadow: {
                        color: 'rgba(0,0,0,0.1)',
                        offsetX: 0,
                        offsetY: 2,
                        opacity: 0.15,
                        width: 8
                    },
                    style: {
                        fontSize: '14px',
                        fontWeight: '400'
                    },
                    useHTML: true
                },
                plotOptions: {
                    dependencywheel: {
                        curveFactor: 0.55,
                        colorByPoint: false,
                        borderWidth: 1,
                        borderColor: '#ffffff',
                        dataLabels: {
                            style: {
                                fontSize: '11px',
                                fontWeight: '600',
                                textOutline: 'none'
                            }
                        },
                        levels: [{
                            level: 1,
                            colorByPoint: false
                        }]
                    }
                },
                series: [{
                    keys: ['from', 'to', 'weight'],
                    type: 'dependencywheel',
                    name: 'Interactions',
                    data: links,
                    nodes: nodesArray,
                    tooltip: {
                        pointFormatter: function () {
                            return `
                                <div style="padding: 10px;">
                                    <div style="font-size: 15px; color: #1d1d1f; font-weight: 600; margin-bottom: 8px;">
                                        ${this.from} ‚Üî ${this.to}
                                    </div>
                                    <div style="margin-bottom: 4px;">
                                        <span style="color: #1d1d1f; font-weight: 600;">Consistency: ${Math.round(this.consistency * 100)}%</span>
                                    </div>
                                    <div style="margin-bottom: 4px;">
                                        <span style="color: #6e6e73;">Frames: ${this.weight} / ${totalFrames}</span>
                                    </div>
                                    <div style="color: #6e6e73; font-size: 12px; margin-top: 6px; padding-top: 6px; border-top: 1px solid #e8e8ed;">
                                        ${this.types}
                                    </div>
                                </div>
                            `;
                        }
                    }
                }]
            });
        }

        // Switch between chart types
        function switchChart(type) {
            currentChartType = type;
            
            // Update button states
            document.getElementById('arcBtn').classList.toggle('active', type === 'arc');
            document.getElementById('chordBtn').classList.toggle('active', type === 'chord');
            document.getElementById('heatmapBtn').classList.toggle('active', type === 'heatmap');
            document.getElementById('filteredHeatmapBtn').classList.toggle('active', type === 'filteredHeatmap');
            document.getElementById('areaBtn').classList.toggle('active', type === 'area');
            document.getElementById('lineBtn').classList.toggle('active', type === 'line');
            
            // Show/hide controls
            const sliderControl = document.getElementById('sliderControl');
            const logScaleControl = document.getElementById('logScaleControl');
            const colorSchemeControl = document.getElementById('colorSchemeControl');
            const interactionFilterControl = document.getElementById('interactionFilterControl');
            const arcLegend = document.getElementById('arcLegend');
            
            if (type === 'arc' || type === 'chord') {
                sliderControl.classList.remove('hidden');
                logScaleControl.classList.add('hidden');
                colorSchemeControl.classList.remove('hidden');
                interactionFilterControl.classList.remove('hidden');
                arcLegend.style.display = 'block';
            } else if (type === 'heatmap') {
                sliderControl.classList.add('hidden');
                logScaleControl.classList.add('hidden');
                colorSchemeControl.classList.remove('hidden');
                interactionFilterControl.classList.remove('hidden');
                arcLegend.style.display = 'none';
            } else if (type === 'filteredHeatmap') {
                sliderControl.classList.remove('hidden');
                logScaleControl.classList.add('hidden');
                colorSchemeControl.classList.remove('hidden');
                interactionFilterControl.classList.remove('hidden');
                arcLegend.style.display = 'none';
            } else if (type === 'line') {
                sliderControl.classList.add('hidden');
                logScaleControl.classList.remove('hidden');
                colorSchemeControl.classList.remove('hidden');
                interactionFilterControl.classList.add('hidden');
                arcLegend.style.display = 'none';
            } else if (type === 'area') {
                sliderControl.classList.add('hidden');
                logScaleControl.classList.add('hidden');
                colorSchemeControl.classList.add('hidden');
                interactionFilterControl.classList.add('hidden');
                arcLegend.style.display = 'none';
            } else {
                sliderControl.classList.add('hidden');
                logScaleControl.classList.add('hidden');
                colorSchemeControl.classList.add('hidden');
                interactionFilterControl.classList.add('hidden');
                arcLegend.style.display = 'none';
            }
            
            // Render appropriate chart
            if (type === 'arc') {
                updateChart(currentThreshold);
            } else if (type === 'chord') {
                updateChordDiagram(currentThreshold);
            } else if (type === 'heatmap') {
                updateHeatmap();
            } else if (type === 'filteredHeatmap') {
                updateFilteredHeatmap(currentThreshold);
            } else if (type === 'area') {
                updateAreaChart();
            } else if (type === 'line') {
                updateLineChart(useLogScale);
            }
        }

        // Update heatmap
        function updateHeatmap() {
            // Filter by interaction types
            const filteredData = allInteractionsData.filter(d => {
                if (selectedInteractionTypes.size === 0) return false;
                const typesString = d.typesArray.join('; ');
                return matchesSelectedTypes(typesString);
            });
            
            // Get unique residues from Chain A and Chain B
            const chainAResidues = new Set();
            const chainBResidues = new Set();
            
            filteredData.forEach(interaction => {
                chainAResidues.add(interaction.id1);
                chainBResidues.add(interaction.id2);
            });
            
            const chainAArray = Array.from(chainAResidues).sort((a, b) => {
                const numA = parseInt(a.match(/\d+/)[0]);
                const numB = parseInt(b.match(/\d+/)[0]);
                return numA - numB;
            });
            
            const chainBArray = Array.from(chainBResidues).sort((a, b) => {
                const numA = parseInt(a.match(/\d+/)[0]);
                const numB = parseInt(b.match(/\d+/)[0]);
                return numA - numB;
            });
            
            // Create heatmap data
            const heatmapData = [];
            filteredData.forEach(interaction => {
                const xIndex = chainAArray.indexOf(interaction.id1);
                const yIndex = chainBArray.indexOf(interaction.id2);
                
                if (xIndex !== -1 && yIndex !== -1) {
                    heatmapData.push({
                        x: xIndex,
                        y: yIndex,
                        value: interaction.consistency,
                        name: `${interaction.id1} ‚Üî ${interaction.id2}`,
                        types: interaction.typesArray.join('; '),
                        frameCount: interaction.frameCount
                    });
                }
            });
            
            document.getElementById('visibleInteractions').textContent = heatmapData.length;
            
            if (chart) {
                chart.destroy();
            }
            
            chart = Highcharts.chart('chartContainer', {
                chart: {
                    type: 'heatmap',
                    backgroundColor: 'transparent',
                    height: 800
                },
                title: {
                    text: `Residue Interaction Heatmap (${heatmapData.length} interactions)`,
                    style: {
                        fontSize: '24px',
                        fontWeight: '600',
                        color: '#1d1d1f'
                    }
                },
                subtitle: {
                    text: 'Chain A (X-axis) ‚Üî Chain B (Y-axis) | Color intensity = Consistency',
                    style: {
                        fontSize: '17px',
                        color: '#6e6e73'
                    }
                },
                credits: {
                    enabled: false
                },
                xAxis: {
                    categories: chainAArray,
                    title: {
                        text: 'Chain A Residues',
                        style: {
                            fontSize: '15px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    labels: {
                        rotation: -45,
                        style: {
                            fontSize: '11px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    }
                },
                yAxis: {
                    categories: chainBArray,
                    title: {
                        text: 'Chain B Residues',
                        style: {
                            fontSize: '15px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    labels: {
                        style: {
                            fontSize: '11px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    },
                    reversed: true
                },
                colorAxis: {
                    min: 0,
                    max: 1,
                    stops: [
                        [0, '#f5f5f7'],
                        [0.3, '#90CAF9'],
                        [0.5, '#42A5F5'],
                        [0.7, '#1E88E5'],
                        [1, '#0D47A1']
                    ],
                    labels: {
                        formatter: function() {
                            return Math.round(this.value * 100) + '%';
                        },
                        style: {
                            fontSize: '12px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    },
                    minColor: '#f5f5f7',
                    maxColor: '#0D47A1'
                },
                legend: {
                    align: 'right',
                    layout: 'vertical',
                    verticalAlign: 'middle',
                    symbolHeight: 300,
                    symbolWidth: 20,
                    title: {
                        text: 'Consistency',
                        style: {
                            fontSize: '14px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    itemStyle: {
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#1d1d1f'
                    }
                },
                plotOptions: {
                    heatmap: {
                        borderWidth: 1,
                        borderColor: '#ffffff',
                        dataLabels: {
                            enabled: false
                        },
                        states: {
                            hover: {
                                brightness: 0.1,
                                borderColor: '#1d1d1f',
                                borderWidth: 2
                            }
                        }
                    }
                },
                series: [{
                    name: 'Interaction Consistency',
                    data: heatmapData,
                    turboThreshold: 10000
                }],
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.98)',
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: '#d2d2d7',
                    shadow: {
                        color: 'rgba(0,0,0,0.1)',
                        offsetX: 0,
                        offsetY: 2,
                        opacity: 0.15,
                        width: 8
                    },
                    style: {
                        fontSize: '14px',
                        fontWeight: '400'
                    },
                    useHTML: true,
                    formatter: function() {
                        return `
                            <div style="padding: 10px;">
                                <div style="font-size: 15px; color: #1d1d1f; font-weight: 600; margin-bottom: 8px;">
                                    ${this.point.name}
                                </div>
                                <div style="margin-bottom: 4px;">
                                    <span style="color: #1d1d1f; font-weight: 600;">Consistency: ${Math.round(this.point.value * 100)}%</span>
                                </div>
                                <div style="margin-bottom: 4px;">
                                    <span style="color: #6e6e73;">Frames: ${this.point.frameCount} / ${totalFrames}</span>
                                </div>
                                <div style="color: #6e6e73; font-size: 12px; margin-top: 6px; padding-top: 6px; border-top: 1px solid #e8e8ed;">
                                    ${this.point.types}
                                </div>
                            </div>
                        `;
                    }
                }
            });
        }

        // Update filtered heatmap with consistency threshold
        function updateFilteredHeatmap(threshold) {
            // Filter by threshold and interaction types
            const filteredData = allInteractionsData.filter(d => {
                if (d.consistency < threshold) return false;
                if (selectedInteractionTypes.size === 0) return false;
                const typesString = d.typesArray.join('; ');
                return matchesSelectedTypes(typesString);
            });
            
            // Get unique residues from Chain A and Chain B
            const chainAResidues = new Set();
            const chainBResidues = new Set();
            
            filteredData.forEach(interaction => {
                chainAResidues.add(interaction.id1);
                chainBResidues.add(interaction.id2);
            });
            
            const chainAArray = Array.from(chainAResidues).sort((a, b) => {
                const numA = parseInt(a.match(/\d+/)[0]);
                const numB = parseInt(b.match(/\d+/)[0]);
                return numA - numB;
            });
            
            const chainBArray = Array.from(chainBResidues).sort((a, b) => {
                const numA = parseInt(a.match(/\d+/)[0]);
                const numB = parseInt(b.match(/\d+/)[0]);
                return numA - numB;
            });
            
            // Create heatmap data
            const heatmapData = [];
            filteredData.forEach(interaction => {
                const xIndex = chainAArray.indexOf(interaction.id1);
                const yIndex = chainBArray.indexOf(interaction.id2);
                
                if (xIndex !== -1 && yIndex !== -1) {
                    heatmapData.push({
                        x: xIndex,
                        y: yIndex,
                        value: interaction.consistency,
                        name: `${interaction.id1} ‚Üî ${interaction.id2}`,
                        types: interaction.typesArray.join('; '),
                        frameCount: interaction.frameCount
                    });
                }
            });
            
            document.getElementById('visibleInteractions').textContent = heatmapData.length;
            
            if (chart) {
                chart.destroy();
            }
            
            chart = Highcharts.chart('chartContainer', {
                chart: {
                    type: 'heatmap',
                    backgroundColor: 'transparent',
                    height: 800
                },
                title: {
                    text: `Residue Interaction Heatmap (${heatmapData.length} interactions)`,
                    style: {
                        fontSize: '24px',
                        fontWeight: '600',
                        color: '#1d1d1f'
                    }
                },
                subtitle: {
                    text: `Chain A (X-axis) ‚Üî Chain B (Y-axis) | Threshold: ${Math.round(threshold * 100)}% | Color intensity = Consistency`,
                    style: {
                        fontSize: '17px',
                        color: '#6e6e73'
                    }
                },
                credits: {
                    enabled: false
                },
                xAxis: {
                    categories: chainAArray,
                    title: {
                        text: 'Chain A Residues',
                        style: {
                            fontSize: '15px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    labels: {
                        rotation: -45,
                        style: {
                            fontSize: '11px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    }
                },
                yAxis: {
                    categories: chainBArray,
                    title: {
                        text: 'Chain B Residues',
                        style: {
                            fontSize: '15px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    labels: {
                        style: {
                            fontSize: '11px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    },
                    reversed: true
                },
                colorAxis: {
                    min: threshold,
                    max: 1,
                    stops: [
                        [0, '#f5f5f7'],
                        [0.3, '#90CAF9'],
                        [0.5, '#42A5F5'],
                        [0.7, '#1E88E5'],
                        [1, '#0D47A1']
                    ],
                    labels: {
                        formatter: function() {
                            return Math.round(this.value * 100) + '%';
                        },
                        style: {
                            fontSize: '12px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    },
                    minColor: '#f5f5f7',
                    maxColor: '#0D47A1'
                },
                legend: {
                    align: 'right',
                    layout: 'vertical',
                    verticalAlign: 'middle',
                    symbolHeight: 300,
                    symbolWidth: 20,
                    title: {
                        text: 'Consistency',
                        style: {
                            fontSize: '14px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    itemStyle: {
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#1d1d1f'
                    }
                },
                plotOptions: {
                    heatmap: {
                        borderWidth: 1,
                        borderColor: '#ffffff',
                        dataLabels: {
                            enabled: false
                        },
                        states: {
                            hover: {
                                brightness: 0.1,
                                borderColor: '#1d1d1f',
                                borderWidth: 2
                            }
                        }
                    }
                },
                series: [{
                    name: 'Interaction Consistency',
                    data: heatmapData,
                    turboThreshold: 10000
                }],
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.98)',
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: '#d2d2d7',
                    shadow: {
                        color: 'rgba(0,0,0,0.1)',
                        offsetX: 0,
                        offsetY: 2,
                        opacity: 0.15,
                        width: 8
                    },
                    style: {
                        fontSize: '14px',
                        fontWeight: '400'
                    },
                    useHTML: true,
                    formatter: function() {
                        return `
                            <div style="padding: 10px;">
                                <div style="font-size: 15px; color: #1d1d1f; font-weight: 600; margin-bottom: 8px;">
                                    ${this.point.name}
                                </div>
                                <div style="margin-bottom: 4px;">
                                    <span style="color: #1d1d1f; font-weight: 600;">Consistency: ${Math.round(this.point.value * 100)}%</span>
                                </div>
                                <div style="margin-bottom: 4px;">
                                    <span style="color: #6e6e73;">Frames: ${this.point.frameCount} / ${totalFrames}</span>
                                </div>
                                <div style="color: #6e6e73; font-size: 12px; margin-top: 6px; padding-top: 6px; border-top: 1px solid #e8e8ed;">
                                    ${this.point.types}
                                </div>
                            </div>
                        `;
                    }
                }
            });
        }

        // Update area chart
        function updateAreaChart() {
            if (chart) {
                chart.destroy();
            }
            
            // Prepare data for area chart
            const categories = areaData.map(d => `Frame ${d.frame}`);
            const totalBSAData = areaData.map(d => d.totalBSA);
            const polarBSAData = areaData.map(d => d.polarBSA);
            const nonPolarBSAData = areaData.map(d => d.nonPolarBSA);
            
            // Update visible interactions to show average total BSA
            const avgTotalBSA = totalBSAData.reduce((a, b) => a + b, 0) / totalBSAData.length;
            document.getElementById('visibleInteractions').textContent = Math.round(avgTotalBSA) + ' √Ö¬≤';
            
            chart = Highcharts.chart('chartContainer', {
                chart: {
                    type: 'line',
                    backgroundColor: 'transparent',
                    height: 650
                },
                title: {
                    text: 'Total Buried Surface Area Across Frames',
                    style: {
                        fontSize: '24px',
                        fontWeight: '600',
                        color: '#1d1d1f'
                    }
                },
                subtitle: {
                    text: 'Total, POLAR, and NON POLAR Buried Surface Area (√Ö¬≤)',
                    style: {
                        fontSize: '17px',
                        color: '#6e6e73'
                    }
                },
                credits: {
                    enabled: false
                },
                xAxis: {
                    categories: categories,
                    title: {
                        text: 'Frame Index (Time)',
                        style: {
                            fontSize: '15px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    labels: {
                        style: {
                            fontSize: '12px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    }
                },
                yAxis: {
                    title: {
                        text: 'Total Buried Surface Area (√Ö¬≤)',
                        style: {
                            fontSize: '15px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    labels: {
                        style: {
                            fontSize: '12px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    }
                },
                legend: {
                    align: 'center',
                    verticalAlign: 'top',
                    layout: 'horizontal',
                    itemStyle: {
                        fontSize: '14px',
                        fontWeight: '500',
                        color: '#1d1d1f'
                    }
                },
                plotOptions: {
                    line: {
                        lineWidth: 3,
                        marker: {
                            enabled: true,
                            radius: 5,
                            lineWidth: 2,
                            lineColor: '#ffffff'
                        },
                        states: {
                            hover: {
                                lineWidth: 4
                            }
                        }
                    }
                },
                series: [{
                    name: 'Total BSA',
                    data: totalBSAData,
                    color: '#3B6EF5',
                    dashStyle: 'Solid',
                    marker: {
                        symbol: 'circle'
                    }
                }, {
                    name: 'Total POLAR Buried Area',
                    data: polarBSAData,
                    color: '#FF3B30',
                    dashStyle: 'Dash',
                    marker: {
                        symbol: 'square'
                    }
                }, {
                    name: 'Total NON POLAR Buried Area',
                    data: nonPolarBSAData,
                    color: '#34C759',
                    dashStyle: 'Dot',
                    marker: {
                        symbol: 'triangle'
                    }
                }],
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.98)',
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: '#d2d2d7',
                    shadow: {
                        color: 'rgba(0,0,0,0.1)',
                        offsetX: 0,
                        offsetY: 2,
                        opacity: 0.15,
                        width: 8
                    },
                    shared: true,
                    useHTML: true,
                    style: {
                        fontSize: '14px',
                        fontWeight: '400'
                    },
                    formatter: function() {
                        let html = `<div style="padding: 10px;">`;
                        html += `<div style="font-size: 15px; color: #1d1d1f; font-weight: 600; margin-bottom: 8px;">${this.x}</div>`;
                        
                        // Sort by value descending
                        const sortedPoints = this.points.sort((a, b) => b.y - a.y);
                        
                        sortedPoints.forEach(point => {
                            html += `
                                <div style="margin-bottom: 4px;">
                                    <span style="color: ${point.color}; font-weight: 600;">‚óè</span>
                                    <span style="color: #1d1d1f;">${point.series.name}: </span>
                                    <span style="color: #1d1d1f; font-weight: 600;">${point.y.toFixed(2)} √Ö¬≤</span>
                                </div>
                            `;
                        });
                        
                        html += '</div>';
                        return html;
                    }
                }
            });
        }

        // Update line chart (interaction trends)
        function updateLineChart(logScale = false) {
            if (chart) {
                chart.destroy();
            }
            
            // Prepare categories
            const categories = Array.from({length: totalFrames}, (_, i) => `Frame ${i + 1}`);
            
            // Map interaction types to colors using current scheme
            const scheme = COLOR_SCHEMES[currentColorScheme];
            const colorMap = {
                'H-bonds': `rgb(${scheme['h-bond'].join(',')})`,
                'Salt-bridges': `rgb(${scheme['salt-bridge'].join(',')})`,
                'œÄ-œÄ interactions': `rgb(${scheme['pi-pi'].join(',')})`,
                'Cation-œÄ interactions': `rgb(${scheme['cation-anion-pi'].join(',')})`,
                'Anion-œÄ interactions': `rgb(${scheme['cation-anion-pi'].join(',')})`,
                'CH-O/N bonds': `rgb(${scheme['ch-on'].join(',')})`,
                'CH-œÄ interactions': `rgb(${scheme['ch-on'].join(',')})`,
                'Halogen bonds': `rgb(${scheme['halogen'].join(',')})`,
                'Apolar vdW contacts': `rgb(${scheme['vdw'].join(',')})`,
                'Polar vdW contacts': `rgb(${scheme['vdw'].join(',')})`,
                'Proximal contacts': `rgb(${scheme['proximal'].join(',')})`,
                'Clashes': `rgb(${scheme['clash'].join(',')})`
            };
            
            // Create series data (only include non-zero interactions)
            const series = [];
            for (const [type, data] of Object.entries(interactionTrendsData)) {
                const hasNonZero = data.some(value => value > 0);
                if (hasNonZero) {
                    series.push({
                        name: type,
                        data: data,
                        color: colorMap[type] || `rgb(${scheme['h-bond'].join(',')})`,
                        lineWidth: 3,
                        marker: {
                            radius: 5,
                            lineWidth: 2,
                            lineColor: '#ffffff'
                        }
                    });
                }
            }
            
            // Calculate total interactions
            const totalInteractions = series.reduce((sum, s) => {
                const maxVal = Math.max(...s.data);
                return sum + maxVal;
            }, 0);
            
            document.getElementById('visibleInteractions').textContent = series.length;
            
            chart = Highcharts.chart('chartContainer', {
                chart: {
                    type: 'line',
                    backgroundColor: 'transparent',
                    height: 650
                },
                title: {
                    text: 'Interaction Type Trends Across Frames',
                    style: {
                        fontSize: '24px',
                        fontWeight: '600',
                        color: '#1d1d1f'
                    }
                },
                subtitle: {
                    text: `Number of Interactions vs Time${logScale ? ' - Logarithmic Scale' : ''}`,
                    style: {
                        fontSize: '17px',
                        color: '#6e6e73'
                    }
                },
                credits: {
                    enabled: false
                },
                xAxis: {
                    categories: categories,
                    title: {
                        text: 'Time (Frames)',
                        style: {
                            fontSize: '15px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    labels: {
                        style: {
                            fontSize: '12px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    }
                },
                yAxis: {
                    type: logScale ? 'logarithmic' : 'linear',
                    title: {
                        text: `Number of Interactions${logScale ? ' - Log Scale' : ''}`,
                        style: {
                            fontSize: '15px',
                            fontWeight: '600',
                            color: '#1d1d1f'
                        }
                    },
                    labels: {
                        style: {
                            fontSize: '12px',
                            fontWeight: '500',
                            color: '#1d1d1f'
                        }
                    },
                    min: logScale ? 0.1 : 0
                },
                legend: {
                    align: 'right',
                    verticalAlign: 'middle',
                    layout: 'vertical',
                    itemStyle: {
                        fontSize: '13px',
                        fontWeight: '500',
                        color: '#1d1d1f'
                    }
                },
                plotOptions: {
                    line: {
                        lineWidth: 3,
                        states: {
                            hover: {
                                lineWidth: 4
                            }
                        },
                        marker: {
                            enabled: true
                        }
                    }
                },
                series: series,
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.98)',
                    borderRadius: 12,
                    borderWidth: 1,
                    borderColor: '#d2d2d7',
                    shadow: {
                        color: 'rgba(0,0,0,0.1)',
                        offsetX: 0,
                        offsetY: 2,
                        opacity: 0.15,
                        width: 8
                    },
                    shared: true,
                    useHTML: true,
                    style: {
                        fontSize: '14px',
                        fontWeight: '400'
                    },
                    formatter: function() {
                        let html = `<div style="padding: 10px;">`;
                        html += `<div style="font-size: 15px; color: #1d1d1f; font-weight: 600; margin-bottom: 8px;">${this.x}</div>`;
                        
                        // Sort by value descending
                        const sortedPoints = this.points.sort((a, b) => b.y - a.y);
                        
                        sortedPoints.forEach(point => {
                            if (point.y > 0) {
                                html += `
                                    <div style="margin-bottom: 4px;">
                                        <span style="color: ${point.color}; font-weight: 600;">‚óè</span>
                                        <span style="color: #1d1d1f;">${point.series.name}: </span>
                                        <span style="color: #1d1d1f; font-weight: 600;">${point.y}</span>
                                    </div>
                                `;
                            }
                        });
                        
                        html += '</div>';
                        return html;
                    }
                }
            });
        }

        // Slider event listener
        const slider = document.getElementById('consistencySlider');
        const sliderValue = document.getElementById('sliderValue');
        const percentText = document.getElementById('percentText');

        slider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            currentThreshold = value;
            const percent = Math.round(value * 100);
            sliderValue.textContent = percent + '%';
            percentText.textContent = percent + '%';
            if (currentChartType === 'arc') {
                updateChart(value);
            } else if (currentChartType === 'chord') {
                updateChordDiagram(value);
            } else if (currentChartType === 'filteredHeatmap') {
                updateFilteredHeatmap(value);
            }
        });

        // Log scale toggle event listener
        const logScaleToggle = document.getElementById('logScaleToggle');
        logScaleToggle.addEventListener('change', (e) => {
            useLogScale = e.target.checked;
            if (currentChartType === 'area') {
                updateAreaChart(useLogScale);
            } else if (currentChartType === 'line') {
                updateLineChart(useLogScale);
            }
        });

        // Color scheme selector event listener
        const colorSchemeSelect = document.getElementById('colorSchemeSelect');
        colorSchemeSelect.addEventListener('change', (e) => {
            currentColorScheme = e.target.value;
            
            // Update legend colors
            updateLegendColors();
            
            // Refresh current chart
            if (currentChartType === 'arc') {
                updateChart(currentThreshold);
            } else if (currentChartType === 'chord') {
                updateChordDiagram(currentThreshold);
            } else if (currentChartType === 'heatmap') {
                updateHeatmap();
            } else if (currentChartType === 'filteredHeatmap') {
                updateFilteredHeatmap(currentThreshold);
            } else if (currentChartType === 'area') {
                updateAreaChart();
            } else if (currentChartType === 'line') {
                updateLineChart(useLogScale);
            }
        });

        // Update legend colors based on current scheme
        function updateLegendColors() {
            const scheme = COLOR_SCHEMES[currentColorScheme];
            const legendItems = [
                { id: 'h-bond', color: scheme['h-bond'] },
                { id: 'salt-bridge', color: scheme['salt-bridge'] },
                { id: 'pi-pi', color: scheme['pi-pi'] },
                { id: 'cation-anion-pi', color: scheme['cation-anion-pi'] },
                { id: 'ch-on', color: scheme['ch-on'] },
                { id: 'halogen', color: scheme['halogen'] },
                { id: 'vdw', color: scheme['vdw'] },
                { id: 'proximal', color: scheme['proximal'] },
                { id: 'clash', color: scheme['clash'] }
            ];
            
            const legendColors = document.querySelectorAll('.legend-color');
            if (legendColors.length >= 9) {
                legendColors[0].style.background = `rgb(${scheme['h-bond'].join(',')})`;
                legendColors[1].style.background = `rgb(${scheme['salt-bridge'].join(',')})`;
                legendColors[2].style.background = `rgb(${scheme['pi-pi'].join(',')})`;
                legendColors[3].style.background = `rgb(${scheme['cation-anion-pi'].join(',')})`;
                legendColors[4].style.background = `rgb(${scheme['ch-on'].join(',')})`;
                legendColors[5].style.background = `rgb(${scheme['halogen'].join(',')})`;
                legendColors[6].style.background = `rgb(${scheme['vdw'].join(',')})`;
                legendColors[7].style.background = `rgb(${scheme['proximal'].join(',')})`;
                legendColors[8].style.background = `rgb(${scheme['clash'].join(',')})`;
            }
        }

        // Upload Modal Functions
        const BACKEND_URL = 'http://localhost:5001';
        let currentUploadId = null;

        function openUploadModal() {
            document.getElementById('uploadModal').classList.add('show');
        }

        function closeUploadModal() {
            document.getElementById('uploadModal').classList.remove('show');
            document.getElementById('progressContainer').style.display = 'none';
            document.getElementById('progressFill').style.width = '0%';
            currentUploadId = null;
        }

        // Setup dropzone
        function setupDropzone() {
            const dropzone = document.getElementById('dropzone');
            const fileInput = document.getElementById('fileInput');

            dropzone.addEventListener('click', () => {
                fileInput.click();
            });

            dropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropzone.classList.add('dragover');
            });

            dropzone.addEventListener('dragleave', () => {
                dropzone.classList.remove('dragover');
            });

            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });
        }

        // Handle file upload
        async function handleFileUpload(file) {
            if (!file.name.endsWith('.pdb')) {
                alert('Please select a valid PDB file');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            // Show progress
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressText').textContent = 'Uploading file...';
            document.getElementById('progressFill').style.width = '10%';

            try {
                const response = await fetch(`${BACKEND_URL}/upload`, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    currentUploadId = result.id;
                    document.getElementById('progressText').textContent = 'Processing PDB file...';
                    
                    // Start polling for progress
                    pollProgress(result.id);
                } else {
                    alert('Upload failed: ' + (result.error || 'Unknown error'));
                    closeUploadModal();
                }
            } catch (error) {
                console.error('Upload error:', error);
                alert('Upload failed. Make sure the backend server is running on port 5000');
                closeUploadModal();
            }
        }

        // Poll for processing progress
        async function pollProgress(pdbId) {
            try {
                const response = await fetch(`${BACKEND_URL}/status/${pdbId}`);
                const status = await response.json();

                // Update progress
                document.getElementById('progressFill').style.width = status.progress + '%';
                
                if (status.status === 'splitting') {
                    document.getElementById('progressText').textContent = `Splitting PDB into frames... ${status.progress}%`;
                } else if (status.status === 'analyzing') {
                    document.getElementById('progressText').textContent = `Running CoCoMaps analysis... ${status.progress}%`;
                } else if (status.status === 'completed') {
                    document.getElementById('progressText').textContent = 'Processing complete!';
                    
                    // Add new system to list
                    const newSystem = {
                        id: pdbId,
                        name: pdbId,
                        path: pdbId,
                        frames: status.frames
                    };
                    SYSTEMS.push(newSystem);
                    
                    // Refresh sidebar
                    initializeSidebar();
                    
                    // Close modal after short delay
                    setTimeout(() => {
                        closeUploadModal();
                        
                        // Switch to new system
                        switchSystem(pdbId);
                    }, 1500);
                    
                    return;
                } else if (status.status === 'failed') {
                    alert('Processing failed: ' + (status.error || 'Unknown error'));
                    closeUploadModal();
                    return;
                }

                // Continue polling
                setTimeout(() => pollProgress(pdbId), 2000);
                
            } catch (error) {
                console.error('Error polling status:', error);
                setTimeout(() => pollProgress(pdbId), 2000);
            }
        }

        // Initialize
        async function initialize() {
            initializeSidebar();
            initializeInteractionFilter();
            setupDropzone();
            await loadAllInteractions();
            await loadAreaData();
            await loadInteractionTrends();
        }
        
        initialize();
    </script>
</body>
</html>

